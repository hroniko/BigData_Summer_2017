Нам нужны пока что три папки из архива, dim, input и output
dim - словари. Их просто подгрузить как текстфайл
Самое общее, у нас есть на входе (папка input) файлы двух типов (всего пять файлов, просто они содержат разную инфу. Тут, наверное, можно аналогию с таблицами в бд провести. В одном файле есть инфа, которая как ключ, можно по ней найти инфу в другом словаре
Есть папка input, в ней cdr файл, есть jarus_http и jarus_ssl, в них почти об одном и том же, но запись о разной активности (звонки, http и ssl), соответсвенно в них прописаны разные поля, но суть - именно регистрация, когда и какая активность происходила. Еще в них используются разные разделители, поэтому для каждого файла нужно будет использовать отдельно свой парсер, ну точнее split по разному разделителю делать при подгрузке файла и разборе на слова.
Есть еще папка expected, там ожидаемые выходы под каждую стадию обработки (ЭТО ПРИМЕР, ЧТО ДОЛЖНО БЫТЬ НА ВЫХОДАХ РАЗНЫХ СТАДИЙ, к этому нужно стремиться.) Вообще, это для юнит-тестов, но мы решили делать без них пока. Это то, что примерно должно получаться.

Теперь что касается словарей. Есть справочник связи айпи адреса и названия сервиса такси - это файл ips. Этот словарь понадобиться нам, чтобы сопоставить айпишник адреса с сервисами такси. То есть такое то такси (сайт) расположен по такому-то адресу. Там адреса заданы не диапазоном, а просто все, какие есть, с повторением сервиса

Теперь дальше, есть словарь телефонов, соотвествующих каждому сервису такси и разделяющихся по областям, это файл phones. Там сделаны столбцы Город - название такси - Телефон
Телефон - это номер, к которому привязан сервис такси в данном городе. 

Есть еще справочник регионов, файл region. Он уже не для звонков, а для интернет-активности. Внутри три столбца: LAC - CELL - Область
Лак и целл определяют вышку, то есть у нее есть локация, в которой она стоит, и номер самой вышки cell
Вот эти два идентификатора определяют, к какой области вышка относится
По сути, это как составной ключ и поле со значением области
Это все необходимо для выделения сервисов такси по регионам

Нам нужно разделить локальную статистику по лаку и целлу, а для этого в jarus_http есть тоже лак и целл столбцы, разделить только по областям, то есть два ключа определяют одну область. Вышки нужны только чтобы определиться с областью, и все, потом про лак и целл можно забыть и работать с областями


Еще есть справочник хостов, файл dim_host_jarus. Там связка сервиса такси (названия) с адресом хоста такси в сети, то есть нужно будет сопоставлять название сервиса и url
Айпишники из этого файла брать не нужно, есть у нас отдельный справочник для айпишников
В этом файле разделителем служит ;
А в файле ips - уже таб, то есть писать в парсере сплит по "\t"


Далше входные данные, там есть файл cdr, тут нам нужны те звонки, где есть номер сервиса, причем звонки с определенной длительностью (больше 5 секунд), совершенные в определенном регионе, то есть пределах тех самых лаков и целлов
Теперь файлы jarus (оба файла - по идее, как я понял, их надо просто склеить в одну rdd). Вот в них есть идентификатор абонента  - его телефонный номер (третий столбец), время (таймстемп в unix-формате) - первый столбец
(там это урезанное до секунд время, типа отсчет с определенного числа 1972 года, когда первый unix выпущен был, его надо будет подгружать и конвертировать в нормальное время, используя библиотеку Joda time)
Вроде как надо сначала на 1000 домножить, а потом конвертировать
Загружаем этот файл jarus как textFile, да и вообще все эти файлы

Чтобы узнать длительность, каждая транзакция имеет свое время записи, мы вытаскиваем первое поле (вот этот таймстемп) и приводим его к лонгу, потом домножаем на тысячу и передаем в конструктор JodaTime'вского таймстемпа, он вроде как сам поймет, как привести в правильной дате-времени, а потом можно в стринг переделать. А чтобы длительность определить, нужно идти по всему массиву транзакций с одинаковым идентификатором и при каждом новом вхождении брать разницу таймстемпа первого и текущего. То есть идем по строкам и смотрим, подходит или нет, если подходит, сравниваем таймтемпы, ну точнее вычислем длительность и проверяем, не превысила ли она 60 минут. Как только превысила, считаем, что одна поездка на такси закончена, и начинается вторая

Дальше, в этом файле нужна будет дата (первый столбец), номер абонента (третий столбец, по нему будем проводить агрегирование в первую очередь), затем тут нам нужны будут пара лас и целл (7 и 8 столбец, их можно так и оставлять разделенными пробелом, чтобы был единый ключ для последующей склейки по ключу), чтобы потом заменить эту пару на регион
Там еще есть такой момент, что в данных встречаются рандомные данные, у которых лак и целл не попали в словарь, такие данные надо просто не прогружать
(да, в этом файле jarus разделитель это таб, строку по нему разбиваем)

Еще нам нужен 9 столбец (хост), а десятый не нужен (оставшаяся часть url), это в http, а в jurus_ssl уже вместо хоста брать айпишник
Это все потому,что данные неоднородные, и нам типо из разных источников надо сопоставить

!!! Там еще надо определить, клиент или водитель заходили на сервис, и в итоговых данных проставить что-то типо флага (0 или 1), кто это был. А определять по длительности сессии (у водителя как правило короткие сессии, но в течение нескольких часов они повторяются, а у клиентов не более часа, но уже не повторяются) Про это дальше написал.



Есть cdr файл. Тут нам нужны конкретно звонки, где фигурирует номер сервиса, которые являются звонками с определенной длительностью, то есть там больше пяти секунд, совершенные в определенном регионе (т.е. в пределах некоторых лаков и целлов)

Сначала будем проводить агрегирование по номеру абонента


CDR большого размера, там порядка 60 полей
Разделитель - это вертикальная черта "\\|"

Нам понадобятся поля (при условии, что отсчет с нулевого идет):

2 - дата-время в формате yyyyMMddHHmmss
6 - call_action_code = 2 (нужно проверить, что он равен двойке - то есть это исходящий вызов от человека на сервис такси)
8 - call_duration_seconds - продолжительность вызова, она должна быть больше пяти (тут используем фильтр) Перевести в инт и потом сравнивать
9 - call_to_tn_sgsn - Это куда звонят, то есть это номер сервиса ПРОВЕРЯТЬ это поле на вхождение в словарь!!!
10 - calling_no_ggsn - Это кто звонит
32 - basic_service_type - должен быть равен "V" ПРОВЕРЯТЬ, что оно равно V
26 - Lac
23 - Cell

9, 32 поля позволяют точнее идентифицировать транзакцию


Вся эта штука подразумевает, что изначально мы все это прочитали как массив строк, сделали сплит, и получили массив строк

Соотвественно тот, кто звонит, его не нужно проверять, а просто забирать,
А вот нужно проверять, что звонок именно совершается по номеру такси




/////////////////////

Что должно получиться: (разделитель везде использовать таб)  - <--- Это все называется агрегат такси-сервисов. То есть у нас агрегирующая связка - это сервис и регион
1. Дата до дня по транзакциям 20170105 (дата расчета общая, у нас расчет идет ежедневный) В теории у нас должна расчитываться неделя. То есть расчет запускается один раз, за этот расчет рассчитывается вся неделя сразу. Можно написать приложение, которое запускается ежедневно и считает один день. ЭТО ВАЖНЫЙ НЮАНС! Я так и делал, расчет по одному дню.
То есть из общей выборки данных забрать только те транзакции, которые соответсвуют только текущей дате рассчета

Особнно это актуально в плане таймстемпа яруса, тут важно не ошибиться при конвертировании, а вот с cdr там все понятно, там JodaTime все сама проверит нормально


2. Второе поле - название сервиса

3. Тип сервиса: онлайн (1) или оффлайн (0), чтобы понять, откуда приехала транзакция, из яруса или cdr'ра

4. Город 
Если для оффлайн транзакции можно определить город путем проверки по справочнику телефонов, то есть там конкретно указано, что такой-то номер относится к такому-то городу,
то для проверки принадлежности интернет-транзакции мы используем только Лак-Целл, по нему мы можем определить исключительно область, но не город. Поэтому проставляем заглушку - число -99

5. Регион

6. Количество поездок по данному сервису



А. Сначала делаем список всех транзакций, даже не уникальных (stage1 ), сохраняем в файл
Б. Потом на основе этого списка всех транзакций делаем агрегировнаие до пользователя. Тут мы уже строим не до сервиса и города, а идентифицируем человека
	и здесь как рааз подсчитываем следующее:
	1 - тип сервиса (оффлайн 0 / онлайн 1)
	2 - является ли пользователь водителем такси или нет (1 - водитель, 0 - нет)
	3 - количество его поездок по данному региону (например, три поездки по данному региону)
В. Финальная агрегация до сервиса и региона



По поводу подсчета количества поездок. Мы пользуемся упрощенной схемой:
- по интернет-транзакциям каждое посещение, каждый засвет на uder и т.д. будем считать поездкой. То есть находим вхождение, ставим counter поездки. То есть если есть вхождение в словарь с сервисами данной транзакции, то можно смело добавлять каунтер поздки.

- в CDR мы  просто отфильтровываем по условиям, которые выше. То есть дата должна совпадать с датой рачета (смотря как вы будете рассчитывать)!!!!!!! (не забыть!!!),
То же самое, звонки считать поездками



По поводу подсчета водителей, тут посложнее. Водителей мы можем пропалить только в ярусах. Чтобы понять, что пользователь водитель, у нас общая продолжительность сессии (то есть вот первая транзакция число, приходит вторая транзакция со временем), так вот у нас должна быть разница между двумя соседними транзакциями менее 60 минут и общая продолжительность дневной сесии должна быть больше 2х часов. То есть это говорит о том, что он не просто там катался на такси, а он целый рабочий день профигачил, то есть несколько часов он пользовался сервисами с несколькими сессиями


По CDR'у тоже нужно будет посмотреть сессии (ВАЖНЫЙ МОМЕНТ!!!!!). У нас поездкой в СВR кроме вот тех всех условий и попадания будет считаться следующее: если в течение часа происходит несколько звонков, то считать это одной поездкой. То есть общая сессия должна быть в пределах часа, не менее. То есть разница между звонками должна быть не менее часа. ТО ЕСТЬ! Нам нужно проверить, что пользователь не просто  часто звонил в сервис. Ну, например, он просто пытается до водителя дозвониться или в сервис узнать, где его машина. Это не является поездкой. У нас поездкой счиатется общая транзакция, общая сессия в рамках одного часа. То есть нужно фильтровтаь такие ситуации. Тоже нужно считать сессии. 

То есть накапливаем общую сессию, и как только общий интервал сессии превышает час, то это будет уже вторая поездка. Если же общее время поездок укладывается в один час, то это, возможно, все еще одна поездка. Это он все еще вызванивает сервис. То есть проверять, что в течение часа от первого засвета по оффлайн транзакции не может быть более одной поездки.


ВСЕ СЕСИИИ СЧИТАТЬ ОТ ПЕРВОГО ВХОЖДЕНИЯ!

Работа с JodaTime:

Мы можем взять JodaTime, заранее определить для нее формат, и потом при помощи вот такого объекта перевожить дату туда и обратно:




import org.joda.time.format.DateTimeFormat
import org.joda.time.{DateTime, DateTimeZone}

DataTimeFormat.forPattern("yyyyMMddHHmmss").parseDateTime("20170103120000").withZone(DateTimeZone.forID("UTC")) // это парсер
// А вот акм можно парсить время SDR'а:
val date = DateTimeFirmat.toPAttern("yyyyMMddHHmmss").parseDateTime("20170108000000")


А вот таким образом можно таймстемп яруса переводить в общепринятый таймстемп Joda 
new DateTime(1483315200L * 1000)